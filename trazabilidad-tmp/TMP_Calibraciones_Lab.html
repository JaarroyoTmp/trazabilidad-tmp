<script type="module">
/* ========= CONFIG SUPABASE ========= */
const SUPABASE_URL = "https://uukxdslfmxesufuxjzvt.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV1a3hkc2xmbXhlc3VmdXhqenZ0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjExMjg5MjksImV4cCI6MjA3NjcwNDkyOX0.7bmDUEQTfl6Y5jdzORyFZUFtOs7GM0dNdfp1zsURkWw";

/* ========= ESTADO ========= */
const state = {
  online: false,
  instrumento: null,
  patrones: [],
  patronesSeleccionados: [],
  puntosPage: { patronId:null, from:0, size:1000, cache:[] },
  plan: [],
  mediciones: {},
  resultados: {}
};

/* ========= UTILIDADES ========= */
const $ = q => document.querySelector(q);
const $$ = q => Array.from(document.querySelectorAll(q));
const fmt = (n,d=3) => Number(n).toFixed(d);
const parseNum = (v) => {
  if (typeof v === 'number') return v;
  if (v===null || v===undefined) return 0;
  const n = Number(String(v).trim().replace(',','.'));
  return Number.isFinite(n)? n : 0;
};
const uid = () => Math.random().toString(36).slice(2,9);
const fechaISO = s => { if(!s) return null; const d=new Date(s); return Number.isNaN(+d)? null : d; };
const setBadge = ok => {
  const b = $("#onlineBadge");
  b.textContent = ok ? "Online (Supabase)" : "Offline";
  b.classList.toggle("online", ok);
  b.classList.toggle("offline", !ok);
  state.online = ok;
};

/* ========= NORMALIZAR FECHAS ========= */
/* Acepta 'YYYY-MM-DD' o 'DD/MM/YYYY' y devuelve 'YYYY-MM-DD' */
function fixDate(d){
  if (!d) return null;
  const v = String(d).trim();
  // Ya viene como tipo date HTML → YYYY-MM-DD
  if (/^\d{4}-\d{2}-\d{2}$/.test(v)) return v;
  // Formato español DD/MM/YYYY
  if (v.includes("/")){
    const [dia,mes,ano] = v.split("/");
    if (dia && mes && ano) return `${ano}-${mes}-${dia}`;
  }
  return v;
}

/* ========= MODO LOCAL ========= */
if (location.protocol === "file:") $("#localBanner").classList.add("show");

/* ========= SUPABASE ========= */
let supabase = null;
async function ensureSupabase(){
  if (!SUPABASE_URL.startsWith("http")) { setBadge(false); return null; }
  if (!supabase) {
    try {
      const { createClient } = await import("https://esm.sh/@supabase/supabase-js@2.45.5");
      supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    } catch(e){ console.warn(e); supabase=null; }
  }
  setBadge(!!supabase);
  return supabase;
}

/* ========= ACTUALIZAR FECHAS EN SUPABASE ========= */
async function actualizarFechasEnSupabase(codigoInstrumento, fechaCal, proxCal) {
  await ensureSupabase();
  if (!supabase) {
    alert("No se pudo conectar con Supabase (modo offline).");
    return;
  }

  const fechaOk = fixDate(fechaCal);
  const proxOk  = fixDate(proxCal);

  const { error } = await supabase
    .from("instrumentos")
    .update({
      fecha_ultima_cal: fechaOk,
      proxima_cal: proxOk
    })
    .eq("codigo", codigoInstrumento);

  if (error) {
    console.error("Error al actualizar Supabase:", error);
    alert("Error subiendo las fechas a Supabase.");
  } else {
    console.log("Fechas de calibración actualizadas en Supabase.");
  }
}

/* ========= CARGA INSTRUMENTO ========= */
async function cargarInstrumento(){
  const codigo = $("#insCodigo").value.trim();
  if (!codigo) return alert("Teclea un código de instrumento.");
  await ensureSupabase();

  let inst=null;
  if (supabase){
    const { data, error } = await supabase.from("instrumentos").select("*").eq("codigo", codigo).maybeSingle();
    if (error) console.warn(error);
    inst=data;
  } else {
    inst={ codigo, descripcion:"Tampón liso P/NP", fabricante_tipo:"N/A", rango:"Ø8 H7", unidad_base:"mm", fecha_ultima_cal:"2024-11-03", proxima_cal:"2025-11-03" };
  }

  state.instrumento = inst;
  pintarInstrumento();

  await cargarPatrones();

  state.plan=[]; state.mediciones={}; state.resultados={};
  $("#planBloques").innerHTML=""; $("#medicionBloques").innerHTML=""; $("#resultadosBox").innerHTML="";
  $("#resumenInstrumento").textContent = "(Pendiente de cálculo de resultados)";
  $("#resumenGlobalBox").textContent = "(Pendiente de cálculo de resultados)";
  $("#trazabilidadBox").textContent = "(Pendiente de cálculo de resultados)";
  $("#patronesSelChips").innerHTML=""; state.patronesSeleccionados=[];
  alert("Instrumento cargado correctamente.");
}

function pintarInstrumento(){
  const ins=state.instrumento||{};
  $("#insDescripcion").value = ins.descripcion||"";
  $("#insFabTipo").value = ins.fabricante_tipo||"";
  $("#insRango").value = ins.rango||"";
  $("#unidadBase").value = ins.unidad_base||"mm";
  $("#insUltima").value = ins.fecha_ultima_cal || "—";
  $("#insProx").value = ins.proxima_cal || "—";

  const est = $("#insEstado");
  let cl="ok", txt="OK";
  const prox = fechaISO(ins.proxima_cal);
  const hoy = new Date();
  if (prox && hoy>prox){ cl="bad"; txt="FUERA"; }
  else if (prox && (+prox - +hoy) < 1000*60*60*24*30){ cl="warn"; txt="PRÓXIMA"; }
  est.className="status "+cl; est.textContent=txt;
}

/* ========= CATALOGO DE PATRONES ========= */
async function cargarPatrones(){
  await ensureSupabase();
  if (supabase){
    const { data, error } = await supabase.from("patrones").select("*").order("descripcion",{ascending:true});
    if (error) console.warn(error);
    state.patrones = data||[];
  } else {
    state.patrones = [
      {id:"1288", codigo:"1288", descripcion:"Banco TRIMOS TELMA 500 — Máquina de una coordenada horizontal", u_k2:0.002, nota:"—"},
      {id:"180456", codigo:"180456", descripcion:"Juego de bloques patrón 0–100 mm", u_k2:0.001, nota:"—"}
    ];
  }
}

/* ========= DIALOGO PATRONES (MULTI) ========= */
$("#btnSelPatrones").addEventListener("click", async ()=>{
  if (!state.patrones.length) await cargarPatrones();
  const dlg=$("#dlgPatrones"), rows=$("#patronRows"), filter=$("#patronFilter");
  const draw=()=>{
    const f=(filter.value||"").toLowerCase();
    rows.innerHTML = state.patrones
      .filter(p=> !f || (p.descripcion||"").toLowerCase().includes(f) || (p.codigo||"").toLowerCase().includes(f))
      .map(p=>`
        <tr class="sel-row">
          <td><input type="checkbox" value="${p.id}"></td>
          <td>${p.codigo||p.id}</td>
          <td>${p.descripcion||"—"}</td>
          <td>${fmt(p.u_k2??0.002)}</td>
          <td>${p.nota||"—"}</td>
        </tr>`).join('');
  };
  draw(); filter.oninput=draw;
  dlg.showModal();

  $("#cancelPatrones").onclick=()=>dlg.close();
  $("#okPatrones").onclick=()=>{
    const ids = Array.from(rows.querySelectorAll('input[type="checkbox"]:checked')).map(x=>x.value);
    if (!ids.length) return alert("Selecciona al menos un patrón.");
    state.patronesSeleccionados = state.patrones.filter(p=> ids.includes(String(p.id)));
    $("#patronesSelChips").innerHTML = state.patronesSeleccionados.map(p=>`<span class="chip">${p.codigo||p.id} · ${p.descripcion}</span>`).join('');
    dlg.close();
  };
});

/* ========= ELECCIÓN PATRÓN CUANDO HAY VARIOS ========= */
async function elegirUnoDeSeleccionados(){
  return await new Promise(res=>{
    const options = state.patronesSeleccionados.map((p,i)=>`${i+1}. ${p.codigo||p.id} · ${p.descripcion}`).join('\n');
    const ans = prompt(`Hay varios patrones seleccionados. Indica el número:\n${options}\n\n`, "1");
    const idx = parseInt(ans,10)-1;
    if (Number.isFinite(idx) && idx>=0 && idx<state.patronesSeleccionados.length) res(state.patronesSeleccionados[idx]); else res(null);
  });
}

/* ========= PLAN: Añadir bloque ========= */
$$('button[data-addblock]').forEach(b=>{
  b.addEventListener("click", async ()=>{
    if (!state.instrumento) return alert("Carga un instrumento primero.");
    if (!state.patronesSeleccionados.length) return alert("Selecciona primero 1 o varios patrones.");
    const patron = (state.patronesSeleccionados.length===1)
      ? state.patronesSeleccionados[0]
      : await elegirUnoDeSeleccionados();
    if (!patron) return;
    const puntos = await dialogSelectPuntosExactos(patron.id);
    if (!puntos?.length) return;

    // Lado por bloque para GO/NO GO
    let lado = null;
    if (b.dataset.addblock === "GNG") {
      const ans = prompt("¿Qué lado del atributo vas a calibrar en este bloque? (GO/NOGO)", "GO");
      const norm = (ans || "GO").toUpperCase().replace(/\s+/g,"");
      lado = norm === "NOGO" ? "NOGO" : "GO";
    }

    const bloque = {
      id: uid(),
      tipo: b.dataset.addblock,
      patron,
      puntos,
      nombrePatron: `${patron.codigo||patron.id} · ${patron.descripcion}`,
      lado // solo se usa para GNG, el resto queda null
    };
    state.plan.push(bloque);
    renderPlan(); renderMedicion();
  });
});

/* ========= RENDER PLAN ========= */
function renderPlan(){
  const box=$("#planBloques");
  if (!state.plan.length){
    box.innerHTML=`<p class="note">No hay bloques. Añade alguno con los botones superiores.</p>`;
    return;
  }
  box.innerHTML = state.plan.map(b=>`
    <div class="card" style="margin-top:10px">
      <div class="row">
        <div class="pill">
          ${b.tipo}${b.tipo==="GNG" && b.lado ? " · " + b.lado : ""}
        </div>
        <div class="chip">${b.nombrePatron}</div>
        <span class="right mini muted">${b.puntos.length} punto(s) seleccionados</span>
      </div>
      <div class="table-box mt-8">
        <table>
          <thead><tr><th>#</th><th>Nominal</th><th>U(k=2)</th><th>Corrección</th><th>Caract.</th></tr></thead>
          <tbody>
            ${b.puntos.map((p,i)=>`<tr><td>${i+1}</td><td>${fmt(p.valor_nominal)}</td><td>${fmt(p.u_k2)}</td><td>${fmt(p.correccion_patron)}</td><td>${p.caracteristica||"—"}</td></tr>`).join('')}
          </tbody>
        </table>
      </div>
    </div>
  `).join('');
}

/* ========= MEDICION ========= */
function renderMedicion(){
  const box=$("#medicionBloques");
  if (!state.plan.length){
    box.innerHTML=`<p class="note">Primero define el plan (bloques y puntos).</p>`;
    return;
  }
  box.innerHTML = state.plan.map(b=>{
    const filas = b.puntos.map(p=>{
      const key=`${b.id}|${p.id}`;
      const med=state.mediciones[key]||{r:[null,null,null,null,null],media:null,s:null,n:0};
      return `
        <tr data-key="${key}">
          <td>${p.valor_nominal.toFixed(3)}</td>
          ${[0,1,2,3,4].map(i=>`<td><input class="rep" data-idx="${i}" type="text" inputmode="decimal" placeholder="—" value="${med.r[i]??""}"></td>`).join('')}
          <td class="media">${med.media??"0.000"}</td><td class="s">${med.s??"0.000"}</td>
        </tr>`;
    }).join('');
    return `
      <div class="card" style="margin-top:12px">
        <div class="row">
          <div class="pill">
            ${b.tipo}${b.tipo==="GNG" && b.lado ? " · " + b.lado : ""}
          </div>
          <div class="chip">${b.nombrePatron}</div>
        </div>
        <div class="table-box mt-8">
          <table>
            <thead><tr><th>Nominal (ref. patrón exacto)</th><th>R1</th><th>R2</th><th>R3</th><th>R4</th><th>R5</th><th>Media</th><th>σ</th></tr></thead>
            <tbody>${filas}</tbody>
          </table>
        </div>
      </div>`;
  }).join('');

  $$("#medicionBloques input.rep").forEach(inp=>{
    inp.addEventListener('input',()=>{ inp.value = inp.value.replace(',', '.'); });
    inp.addEventListener('change',()=>{
      const tr=inp.closest('tr'); const key=tr.dataset.key; const idx=+inp.dataset.idx;
      const med=state.mediciones[key]||{r:[null,null,null,null,null]};
      med.r[idx]=parseNum(inp.value);
      const vals=med.r.filter(x=>typeof x==='number'&&isFinite(x));
      const n=vals.length;
      const media=n? (vals.reduce((a,b)=>a+b,0)/n) : 0;
      const s=n>1? Math.sqrt(vals.reduce((a,b)=>a+(b-media)**2,0)/(n-1)) : 0;
      med.media=fmt(media); med.s=fmt(s); med.n=n;
      state.mediciones[key]=med;
      tr.querySelector('.media').textContent=med.media; tr.querySelector('.s').textContent=med.s;
    });
  });
}
$("#btnGuardarMed").addEventListener("click",()=>{
  const codigo=$("#insCodigo").value.trim();
  localStorage.setItem(`mediciones:${codigo}`, JSON.stringify(state.mediciones));
  alert("Mediciones guardadas localmente.");
});
$("#goResultados").addEventListener("click",()=>{ calcularResultados(); switchTab('resultados'); });

/* ========= RESULTADOS + INFORME ========= */
function calcularResultados(){
  const ladoGlobal=$("#ladoMed").value;
  const nominalGO=parseNum($("#nominalGO").value);
  const nominalNOGO=parseNum($("#nominalNOGO").value);
  const ref=$("#refError").value;
  const tol=parseNum($("#tolGlobal").value);          // mm
  const uBase=parseNum($("#uBase").value);           // U_patron (mm), k=2 por defecto
  const resolucion = parseNum($("#resolucion").value); // mm
  const kFactor = parseNum($("#factorK").value) || 2;

  const box=$("#resultadosBox");
  if (!state.plan.length){
    box.innerHTML=`<p class="note">No hay plan definido.</p>`;
    return;
  }

  let html="";
  let maxAbsError = 0;
  let maxAbsErrorPlusU = 0;
  let totalPuntos = 0;
  let hayNoApto = false;
  let hayIndeterminado = false;

  for (const b of state.plan){
    const lado = b.lado || ladoGlobal;

    html += `
      <div class="card" style="margin-top:12px">
        <div class="row">
          <div class="pill">
            ${b.tipo}${b.tipo==="GNG" && b.lado ? " · " + b.lado : ""}
          </div>
          <div class="chip">${b.nombrePatron}</div>
          <span class="right mini muted">Nominal bloque (${lado}): ${lado==='GO'?fmt(nominalGO):fmt(nominalNOGO)} mm</span>
        </div>
        <div class="table-box mt-8">
          <table>
            <thead>
              <tr>
                <th>#</th>
                <th>Nominal patrón (mm)</th>
                <th>Corrección (µm)</th>
                <th>Media I (mm)</th>
                <th>Error E (µm)</th>
                <th>U<sub>c</sub> (µm)</th>
                <th>U (µm)</th>
                <th>Tolerancia T (µm)</th>
                <th>Decisión</th>
              </tr>
            </thead>
            <tbody>
    `;
    b.puntos.forEach((p,i)=>{
      const key=`${b.id}|${p.id}`;
      const med=state.mediciones[key]||{};
      const media=parseNum(med.media);   // mm
      const s_mm = parseNum(med.s);      // mm
      const n = med.n || 0;

      let refVal = (ref==="patron") ? p.valor_nominal : (lado==="GO" ? nominalGO : nominalNOGO); // mm
      const error_um = (media - refVal)*1000;   // µm

      // INCERTIDUMBRES
      const U_patron_mm = (p.u_k2 && p.u_k2>0) ? p.u_k2 : uBase;   // U del patrón en mm (k≈2)
      const u_patron_mm = U_patron_mm / (kFactor || 2);            // u_patron en mm

      const u_rep_mm = (n>1) ? (s_mm / Math.sqrt(n)) : 0;          // repetibilidad de la media
      const u_res_mm = resolucion>0 ? (resolucion / Math.sqrt(12)) : 0;

      const uc_mm = Math.sqrt(
        u_patron_mm**2 +
        u_rep_mm**2 +
        u_res_mm**2
      );
      const U_mm = (kFactor || 2) * uc_mm;

      const uc_um = uc_mm*1000;
      const U_um  = U_mm*1000;
      const T_um  = tol*1000;

      const absE = Math.abs(error_um);
      const absEplusU = Math.abs(error_um)+U_um;
      if (absE > maxAbsError) maxAbsError = absE;
      if (absEplusU > maxAbsErrorPlusU) maxAbsErrorPlusU = absEplusU;
      totalPuntos++;

      let decision="INDETERMINADO";
      if (Math.abs(error_um)+U_um <= T_um) decision="APTO";
      else if (Math.abs(error_um)-U_um > T_um) decision="NO APTO";

      if (decision==="NO APTO") hayNoApto = true;
      if (decision==="INDETERMINADO") hayIndeterminado = true;
      const badge = decision==="APTO" ? "success" : (decision==="NO APTO" ? "danger" : "");

      html += `
        <tr>
          <td>${i+1}</td>
          <td>${fmt(p.valor_nominal)}</td>
          <td>${fmt(p.correccion_patron*1000,3)}</td>
          <td>${fmt(media)}</td>
          <td>${fmt(error_um,1)}</td>
          <td>${fmt(uc_um,1)}</td>
          <td>${fmt(U_um,1)}</td>
          <td>${fmt(T_um,1)}</td>
          <td><span class="pill ${badge}">${decision}</span></td>
        </tr>`;
    });
    html += `</tbody></table></div></div>`;
  }
  box.innerHTML=html;

  // --- 1. Ficha instrumento (para informe) ---
  const ins = state.instrumento || {};
  const resumenInst = `
    <p class="mini">
      <strong>Código:</strong> ${ins.codigo || "-"} ·
      <strong>Descripción:</strong> ${ins.descripcion || "-"} ·
      <strong>Fabricante / Tipo:</strong> ${ins.fabricante_tipo || "-"}<br>
      <strong>Rango de medida:</strong> ${ins.rango || "-"} ·
      <strong>Unidad base:</strong> ${ins.unidad_base || "mm"}<br>
      <strong>Última calibración registrada:</strong> ${ins.fecha_ultima_cal || "-"} ·
      <strong>Próxima calibración registrada:</strong> ${ins.proxima_cal || "-"}
    </p>
  `;
  $("#resumenInstrumento").innerHTML = resumenInst;

  // --- 5. Resumen global ---
  let decisionGlobal = "APTO";
  if (hayNoApto) decisionGlobal = "NO APTO";
  else if (hayIndeterminado) decisionGlobal = "INDETERMINADO";

  const resumenGlobal = `
    <p class="mini">
      <strong>Número de bloques:</strong> ${state.plan.length} ·
      <strong>Número total de puntos evaluados:</strong> ${totalPuntos}<br>
      <strong>Máx |E| (µm):</strong> ${fmt(maxAbsError,1)} ·
      <strong>Máx (|E| + U) (µm):</strong> ${fmt(maxAbsErrorPlusU,1)} ·
      <strong>Tolerancia global (µm):</strong> ${fmt(tol*1000,1)}<br>
      <strong>Factor de cobertura usado:</strong> k = ${kFactor || 2}<br>
      <strong>Decisión global según ILAC-G8:</strong>
      <span class="pill ${decisionGlobal==="APTO"?"success":(decisionGlobal==="NO APTO"?"danger":"")}">
        ${decisionGlobal}
      </span>
    </p>
  `;
  $("#resumenGlobalBox").innerHTML = resumenGlobal;

  // --- 6. Trazabilidad ---
  const patronesTxt = (state.patronesSeleccionados||[]).map(p=>`${p.codigo||p.id} · ${p.descripcion||""}`).join("; ");
  const traz = `
    <p class="mini">
      La trazabilidad metrológica se garantiza mediante el uso de patrones materializados cuyo estado de calibración
      se controla en el sistema de gestión de patrones del laboratorio TMP. Para esta calibración se han utilizado
      los siguientes patrones:<br>
      <strong>Patrones empleados:</strong> ${patronesTxt || "No informado"}.
    </p>
    <p class="mini">
      Los valores indicados de corrección del patrón (columna "Corrección") proceden del certificado de calibración
      o, en puntos intermedios, de la interpolación matemática aplicada por el laboratorio. La incertidumbre informada
      corresponde a la incertidumbre expandida U(k) con el factor de cobertura seleccionado en el informe.
    </p>
  `;
  $("#trazabilidadBox").innerHTML = traz;

  // --- Gráfica de errores (primer bloque) ---
  dibujarGraficaErrores();
}

/* ========= GRÁFICA DE ERRORES (primer bloque) ========= */
function dibujarGraficaErrores(){
  const canvas = document.getElementById("grafErrores");
  if (!canvas) return;
  const ctxG = canvas.getContext("2d");
  ctxG.clearRect(0,0,canvas.width,canvas.height);
  const bloque = state.plan[0];
  if (!bloque) {
    ctxG.fillStyle="#9eb9cf";
    ctxG.font="12px Inter";
    ctxG.fillText("Sin datos de bloques.", 10, 20);
    return;
  }

  const ladoGlobal=$("#ladoMed").value;
  const lado = bloque.lado || ladoGlobal;
  const nominalGO=parseNum($("#nominalGO").value);
  const nominalNOGO=parseNum($("#nominalNOGO").value);
  const ref=$("#refError").value;
  const tol=parseNum($("#tolGlobal").value);

  const puntosGraf = [];
  bloque.puntos.forEach(p=>{
    const key=`${bloque.id}|${p.id}`; const med=state.mediciones[key]||{}; const media=parseNum(med.media);
    let refVal = (ref==="patron") ? p.valor_nominal : (lado==="GO" ? nominalGO : nominalNOGO);
    const error = (media - refVal)*1000;
    puntosGraf.push({x:p.valor_nominal, y:error});
  });
  if (!puntosGraf.length){
    ctxG.fillStyle="#9eb9cf";
    ctxG.font="12px Inter";
    ctxG.fillText("Sin mediciones en el primer bloque.", 10, 20);
    return;
  }

  const margin = {left:40,right:10,top:10,bottom:25};
  const xs = puntosGraf.map(p=>p.x);
  const ys = puntosGraf.map(p=>p.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const maxAbsY = Math.max(...ys.map(v=>Math.abs(v)), tol*1000);
  const minY = -maxAbsY, maxY = maxAbsY;

  const sx = v => margin.left + ( (v-minX)/(maxX-minX || 1) ) * (canvas.width - margin.left - margin.right);
  const sy = v => margin.top + ( (maxY-v)/(maxY-minY || 1) ) * (canvas.height - margin.top - margin.bottom);

  ctxG.strokeStyle="#2a4f74";
  ctxG.lineWidth=1;
  ctxG.strokeRect(margin.left,margin.top,canvas.width-margin.left-margin.right,canvas.height-margin.top-margin.bottom);

  const y0 = sy(0);
  ctxG.strokeStyle="#3f6fa3";
  ctxG.beginPath();
  ctxG.moveTo(margin.left,y0);
  ctxG.lineTo(canvas.width-margin.right,y0);
  ctxG.stroke();

  const yTolUp = sy(tol*1000);
  const yTolDown = sy(-tol*1000);
  ctxG.strokeStyle="#66501d";
  ctxG.setLineDash([4,3]);
  ctxG.beginPath(); ctxG.moveTo(margin.left,yTolUp); ctxG.lineTo(canvas.width-margin.right,yTolUp); ctxG.stroke();
  ctxG.beginPath(); ctxG.moveTo(margin.left,yTolDown); ctxG.lineTo(canvas.width-margin.right,yTolDown); ctxG.stroke();
  ctxG.setLineDash([]);

  ctxG.fillStyle="#9eb9cf";
  ctxG.font="10px Inter";
  ctxG.fillText("Error (µm)", margin.left+4, margin.top+10);
  ctxG.fillText("Nominal patrón (mm)", canvas.width/2-40, canvas.height-5);

  ctxG.fillStyle="#58a6ff";
  puntosGraf.forEach(p=>{
    const x = sx(p.x);
    const y = sy(p.y);
    ctxG.beginPath();
    ctxG.arc(x,y,3,0,Math.PI*2);
    ctxG.fill();
  });
}

/* ========= FIRMA ========= */
const sigCanvas = document.getElementById('sigPad');
const ctx = sigCanvas.getContext('2d');
ctx.strokeStyle = '#58a6ff'; ctx.lineWidth = 2.2; ctx.lineCap='round';
let drawing=false, last=null;
function pos(ev){ const r=sigCanvas.getBoundingClientRect(); return {x:(ev.clientX-r.left), y:(ev.clientY-r.top)}; }
sigCanvas.addEventListener('mousedown', e=>{ drawing=true; last=pos(e); });
sigCanvas.addEventListener('mousemove', e=>{ if(!drawing) return; const p=pos(e); ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(p.x,p.y); ctx.stroke(); last=p; });
sigCanvas.addEventListener('mouseup', ()=>drawing=false);
sigCanvas.addEventListener('mouseleave', ()=>drawing=false);
document.getElementById('sigClear').addEventListener('click', ()=>{ ctx.clearRect(0,0,sigCanvas.width,sigCanvas.height); });

/* ========= GUARDADO LOCAL + VALIDACIÓN (MODIFICADO) ========= */
$("#btnGuardarTodo").addEventListener("click", async ()=>{
  const codigo=$("#insCodigo").value.trim();
  const fechaCal = fixDate($("#condFechaCal").value);
  const proxCal  = fixDate($("#firmanteProxima").value);
  const sigData = sigCanvas.toDataURL("image/png");

  const payload = {
    instrumento: state.instrumento,
    patronesSeleccionados: state.patronesSeleccionados,
    plan: state.plan,
    mediciones: state.mediciones,
    condiciones: {
      temp: $("#condTemp").value,
      hum: $("#condHum").value,
      fechaCal,
      obs: $("#condObs").value
    },
    validacion: {
      firmante: $("#firmanteNombre").value.trim(),
      proxima: proxCal,
      firma_png: sigData
    },
    ts: new Date().toISOString()
  };
  localStorage.setItem(`calibracion:${codigo}`, JSON.stringify(payload));

  await actualizarFechasEnSupabase(codigo, fechaCal, proxCal);

  alert("Calibración, condiciones y fechas guardadas (local + Supabase).");
});

/* ========= IMPRESIÓN ========= */
$("#btnImprimir").addEventListener("click",()=>{
  if (!$("#firmanteNombre").value.trim() || !$("#firmanteProxima").value) {
    alert("Completa el nombre y la fecha de próxima calibración antes de imprimir.");
    return;
  }
  window.print();
});

/* ========= SELECTOR DE PUNTOS (NOMINAL EXACTO) ========= */
async function dialogSelectPuntosExactos(patronId){
  await ensureSupabase();
  const dlg=$("#dlgPuntos"), rows=$("#puntosRows"), input=$("#puntoSearchExacto");
  const btnBuscar=$("#btnBuscarPunto"), btnMas=$("#btnCargarMas");
  state.puntosPage = { patronId, from:0, size:1000, cache:[] };

  const draw = () => {
    const puntos = state.puntosPage.cache;
    rows.innerHTML = puntos.map((p,i)=>`
      <tr>
        <td><input type="checkbox" value="${p.id}"></td>
        <td>${i+1}</td>
        <td>${fmt(p.valor_nominal)}</td>
        <td>${fmt(p.u_k2)}</td>
        <td>${fmt(p.correccion_patron)}</td>
        <td>${p.caracteristica||"—"}</td>
      </tr>`).join('');
  };

  async function loadPage(){
    if (!supabase){
      state.puntosPage.cache = [
        {id:patronId+"_0",valor_nominal:8.000,u_k2:0.002,correccion_patron:0,caracteristica:"Interpolado automático"}
      ];
      draw(); return;
    }
    const { from, size } = state.puntosPage;
    const { data, error } = await supabase
      .from("proc_puntos")
      .select("*")
      .eq("patron_id", patronId)
      .order("valor_nominal",{ascending:true})
      .range(from, from+size-1);
    if (error) { console.warn(error); return; }
    state.puntosPage.from += size;
    state.puntosPage.cache = (state.puntosPage.cache||[]).concat((data||[]).map(mapPoint));
    draw();
  }

  async function buscarExacto(){
    const str = input.value.trim().replace(',','.');
    if (!str) return alert("Introduce un nominal exacto (ej. 8.001)");
    const exact = Number(str);
    if (!Number.isFinite(exact)) return alert("Valor no válido.");
    const { data, error } = await supabase
      .from("proc_puntos")
      .select("*")
      .eq("patron_id", patronId)
      .eq("valor_nominal", exact)
      .order("valor_nominal",{ascending:true})
      .limit(50);
    if (error) { console.warn(error); return; }
    const list = (data||[]).map(mapPoint);
    state.puntosPage.cache = list; draw();
    if (!list.length) alert("No existe ese nominal exacto para este patrón.");
  }

  dlg.showModal(); rows.innerHTML=""; await loadPage();
  btnMas.onclick=loadPage; btnBuscar.onclick=buscarExacto;

  return await new Promise(res=>{
    $("#cancelPuntos").onclick=()=>{ dlg.close(); res(null); };
    $("#okPuntos").onclick=()=>{
      const ids = Array.from(rows.querySelectorAll('input[type="checkbox"]:checked")).map(x=>x.value);
      if (!ids.length) return alert("Selecciona al menos un punto.");
      const sel = state.puntosPage.cache.filter(p=> ids.includes(String(p.id)));
      dlg.close(); res(sel);
    };
  });
}
function mapPoint(p){
  return {
    id: p.id || p.uuid || p.pk || uid(),
    valor_nominal: parseNum(p.valor_nominal ?? p.nominal_mm ?? p.nominal ?? 0),
    u_k2: parseNum(p.u_k2 ?? p.u_patron ?? 0),
    correccion_patron: parseNum(p.correccion_patron ?? p.correccion ?? 0),
    caracteristica: p.caracteristica || p.tipo_medicion || ""
  };
}

/* ========= TABS ========= */
function switchTab(name){
  $$('.tab').forEach(t=>t.classList.toggle('active', t.dataset.tab===name));
  $('#tab-plan').classList.toggle('hidden', name!=='plan');
  $('#tab-medicion').classList.toggle('hidden', name!=='medicion');
  $('#tab-resultados').classList.toggle('hidden', name!=='resultados');
  $('#tab-anexo').classList.toggle('hidden', name!=='anexo');
}
$$('.tab').forEach(t=> t.addEventListener('click',()=> switchTab(t.dataset.tab)));

/* ========= BOTONES CABECERA ========= */
$("#btnCargar").addEventListener("click", cargarInstrumento);
$("#btnLimpiar").addEventListener("click", ()=>location.reload());

/* ========= ARRANQUE ========= */
setBadge(false); switchTab('plan');
</script>

